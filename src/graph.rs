
use std::collections::HashSet;

use utils;

#[derive(Debug)]
enum NodeType {
    State,
    Transition
}

#[derive(Debug)]
struct Node {
    node_type: NodeType,
    name: String,
    index: usize,
    source_pos: utils::SourcePos,
    label: String,
    pre: Vec<usize>,
    post: Vec<usize>,
    block_ref: usize,
    delta_before: u32,
    delta_after: u32
}

impl Node {

    fn new(node_type: NodeType, node_name: String, node_index: usize, source_pos: utils::SourcePos, label: String)
           -> Node {
        return Node {
            node_type: node_type,
            name: node_name,
            index: node_index,
            source_pos: source_pos,
            label: label,
            pre: Vec::new(),
            post: Vec::new(),
            block_ref: 0,
            delta_before: 0,
            delta_after:0
        }
    }
    
    fn add_successor(&mut self, succ_index: usize) {
        self.post.push(succ_index)
    }

    fn add_predecessor(&mut self, prec_index: usize) {
        self.pre.push(prec_index)
    }

    fn set_block_ref(&mut self, block_ref: usize) {
        self.block_ref = block_ref
    }

    fn show_lts(&self) -> String {
        format!("\n  {} [label=\"{}\"]; // {}",
                self.name, self.label, self.source_pos.show_lts())
    }
}

struct Block
{
    block_ref: usize,
    node_refs: Vec<usize>,
    pre_refs: HashSet<usize>
}

struct Graph {
    source: String,
    nodes: Vec<Node>,
    blocks: Vec<Block>
}

impl Graph {

    fn add_state(&mut self, state_name: String, source_pos: utils::SourcePos, label: String) -> usize {
        let node = Node::new(NodeType::State, state_name, self.nodes.len(), source_pos, label);
        self.nodes.push(node);
        self.nodes.len() - 1
    }

    fn add_transition(&mut self,
                      start_state_name: String, start_state_index: usize,
                      end_state_name: String, end_state_index: usize,
                      label: String) -> usize {
        let trans_index = self.nodes.len();
        let start_source_pos = self.nodes[start_state_index].source_pos;
 
        let trans_name = format!("T_{}_{}", start_state_name, end_state_name);
        {
            let trans_node = Node::new(NodeType::Transition, trans_name, trans_index, start_source_pos, label);
            self.nodes.push(trans_node);
        }
        {
            let mtrans_node = &mut self.nodes[trans_index];
            mtrans_node.add_predecessor(start_state_index);
            mtrans_node.add_successor(end_state_index);
        }
        
        {
            let start_node = &mut self.nodes[start_state_index];
            start_node.add_successor(trans_index);
        }

        {
            let end_node = &mut self.nodes[end_state_index];
            end_node.add_predecessor(trans_index);
        }

        trans_index
    }

    fn show_nodes(&self) -> String {
        let mut str = "".to_owned();
        for node in &self.nodes {
            str.push_str(&node.show_lts())
        }
            
        //format!("{}", str)
        str
    }

    fn show_edges(&self) -> String {
        let mut str = "".to_owned();
        for pre_node in &self.nodes {
            for post_index in &pre_node.post {
                let post_node = &self.nodes[*post_index];
                str.push_str(&format!("\n  {} -> {};", pre_node.name, post_node.name))
            }
        }
        str
    }

    fn show_graph(&self) -> String {
        let mut str = "".to_owned();
        str.push_str("/* Graph generated by *melts* tool */\n");
        str.push_str(&format!("// @src(\"{}\")\n", self.source));
        str.push_str("digraph {\n");
        str.push_str("\n  /* nodes */\n");
        str.push_str(&self.show_nodes());
        str.push_str("\n  /* edges */\n");
        str.push_str(&self.show_edges());
        str.push_str("\n}\n");
        str 
    }
}
